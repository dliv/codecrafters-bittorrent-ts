{"mappings":";;;AMAA,qEAAqE;AACrE,yCAAyC;AACzC,iDAAiD;AAC1C,MAAM,4CAAiB,IAAI;;;ADD3B,MAAM;IACX,YAAY,AAAS,GAAY,CAAE;aAAd,MAAA;IAAe;IAEpC,WAAW;QACT,OAAO,IAAI,CAAC,GAAG;IACjB;AACF;AAEO,MAAM,kDAAiB;AAAO;AAE9B,MAAM,kDAAiB;IAE5B,YAAY,QAAQ,CAAE;QACpB,MAAM,SAAS,OAAO,IAAI,CAAC;QAC3B,MAAM,MAAM,OAAO,QAAQ,CAAC;QAC5B,CAAA,GAAA,yCAAa,EAAE,GAAG,CAAC,KAAK;QACxB,KAAK,CAAC;QACN,IAAI,CAAC,MAAM,GAAG;IAChB;IACA,WAAW;QACT,OAAO,KAAK,SAAS,CAAC,IAAI,CAAC,GAAG;IAChC;AACF;AAEO,MAAM,kDAAuB;IAClC,WAAW;QACT,OAAO,CAAC,CAAC,CAAC;IACZ;AACF;AAEO,MAAM,kDAAwB;IACnC,WAAW;QACT,OAAO,CAAC,CAAC,CAAC;IACZ;AACF;AAEO,MAAM,iDAAsB;IACjC,WAAW;QACT,OAAO,CAAC,CAAC,CAAC;IACZ;AACF;AAEO,MAAM,kDAAuB;IAClC,WAAW;QACT,OAAO,CAAC,CAAC,CAAC;IACZ;AACF;AAEO,MAAM,kDAAuB;IAClC,WAAW;QACT,OAAO,CAAC,EAAE,CAAC;IACb;AACF;AAEO,MAAM,kDAAyB;IACpC,WAAW;QACT,OAAO,CAAC,EAAE,CAAC;IACb;AACF;;;ADjDO,MAAM;IACX,YACE,AAAS,SAAkB,EAAE,EAC7B,AAAS,aAAsB,EAAE,CACjC;aAFS,SAAA;aACA,aAAA;QAET,IAAI,CAAC,UAAU,GAAG,cAAc,EAAE;QAClC,IAAI,CAAC,MAAM,GAAG,UAAU,EAAE;IAC5B;IAEA,MAAM;QACJ,MAAM,MAAM,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC;QAC/B,IAAI,eAAe,CAAA,GAAA,yCAAa,GAC9B,OAAO,IAAI,CAAC,GAAG,CAAC,IAAI,CAAA,GAAA,yCAAc;QAEpC,IAAI,eAAe,CAAA,GAAA,wCAAY,GAC7B,OAAO,IAAI,CAAC,GAAG,CAAC,IAAI,CAAA,GAAA,yCAAa;QAEnC,MAAM,IAAI,MAAM;IAClB;IAEA,UAAU;QACR,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,EACzB,OAAO,IAAI,CAAC,QAAQ;QAEtB,OAAO,IAAI,CAAC,GAAG,GAAG,OAAO;IAC3B;IAEA,IAAI,CAAC,EAAE;QACL,IAAI,aAAa,IAAI,CAAC,UAAU;QAChC,IAAI,aAAa,CAAA,GAAA,yCAAa,GAC5B,aAAa,WAAW,MAAM,CAAC;aAC1B,IAAI,aAAa,CAAA,GAAA,wCAAY,GAClC,aAAa,WAAW,MAAM,CAAC;aAC1B,IAAI,aAAa,CAAA,GAAA,yCAAc,GAAG;YACvC,MAAM,MAAM,WAAW,EAAE,CAAC;YAC1B,IAAI,CAAE,CAAA,eAAe,CAAA,GAAA,yCAAa,CAAA,GAChC,MAAM,IAAI,MAAM;YAElB,aAAa;mBAAI;aAAW;YAC5B,WAAW,GAAG;QAChB,OAAO,IAAI,aAAa,CAAA,GAAA,yCAAa,GAAG;YACtC,MAAM,MAAM,WAAW,EAAE,CAAC;YAC1B,IAAI,CAAE,CAAA,eAAe,CAAA,GAAA,wCAAY,CAAA,GAC/B,MAAM,IAAI,MAAM;YAElB,aAAa;mBAAI;aAAW;YAC5B,WAAW,GAAG;QAChB;QAEA,MAAM,cACJ,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC,eAAe,CAAA,GAAA,yCAAa,KAC/C,CAAE,CAAA,aAAa,CAAA,GAAA,yCAAc,CAAA,KAC7B,CAAE,CAAA,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,eAAe,CAAA,GAAA,yCAAa,CAAA;QAE/C,MAAM,aACJ,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC,eAAe,CAAA,GAAA,wCAAY,KAC9C,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,eAAe,CAAA,GAAA,yCAAO,KACrC,CAAE,CAAA,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,eAAe,CAAA,GAAA,yCAAe,CAAA;QAEjD,MAAM,eACJ,CAAC,cACD,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC,eAAe,CAAA,GAAA,wCAAY,KAC9C,CAAE,CAAA,aAAa,CAAA,GAAA,yCAAa,CAAA,KAC5B,CAAE,CAAA,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,eAAe,CAAA,GAAA,wCAAY,CAAA;QAE9C,IAAI,eAAe,cACjB,MAAM,IAAI,MAAM;QAElB,IAAI,cAAe,CAAA,gBAAgB,WAAU,GAC3C,MAAM,IAAI,MAAM;QAGlB,MAAM,aACJ,eAAe,eACX,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAA,GAAA,yCAAa,OACpC,aACE,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAA,GAAA,yCAAe,OACtC,IAAI,CAAC,MAAM;QAEnB,OAAO,IAAI,0CAAY,WAAW,MAAM,CAAC,IAAI;IAC/C;IAEA,WAAW;QACT,MAAM,MAAM,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC;QAC7B,MAAM,SAAS,KAAK,KAAK,CAAC;QAC1B,MAAM,MAAM,KAAK,SAAS,CAAC;QAC3B,OAAO;IACT;AACF;;;;AGnGO,MAAM,4CAAS,CAAC,KAAe,GAAG,UAAU,CAAC;AAE7C,MAAM,4CAAI,0CAAO;AACjB,MAAM,4CAAI,0CAAO;AACjB,MAAM,4CAAQ,0CAAO;AACrB,MAAM,4CAAS,0CAAO;AACtB,MAAM,4CAAK,0CAAO;AAClB,MAAM,4CAAK,0CAAO;AAClB,MAAM,4CAAI,0CAAO;AACjB,MAAM,4CAAI,0CAAO;;;AJLxB,MAAM,oCAAc,CAAC,IAAM,OAAO,QAAQ,CAAC,OAAO,YAAY,CAAC,IAAI;AAM5D,SAAS,0CAAc,KAAK,EAAE,MAAM,CAAC,EAAE,SAAS,IAAI,CAAA,GAAA,yCAAU,GAAG;IACtE,IAAI,MAAM,MAAM,MAAM,EAAE;QACtB,QAAQ,KAAK,CAAC,CAAC,eAAe,EAAE,IAAI,GAAG,EAAE,MAAM,MAAM,CAAC,CAAC;QACvD,OAAO,OAAO,OAAO,IAAI,2DAA2D;IACtF;IACA,IAAI,QAAQ,MAAM,MAAM,EACtB,OAAO;IAET,IAAI,KAAK,CAAC,IAAI,KAAK,CAAA,GAAA,yCAAA,GACjB,OAAO,0CAAc,OAAO,MAAM,GAAG,OAAO,GAAG,CAAC,IAAI,CAAA,GAAA,wCAAY;IAElE,IAAI,KAAK,CAAC,IAAI,KAAK,CAAA,GAAA,yCAAA,GACjB,OAAO,0CAAc,OAAO,MAAM,GAAG,OAAO,GAAG,CAAC,IAAI,CAAA,GAAA,yCAAa;IAEnE,IAAI,KAAK,CAAC,IAAI,KAAK,CAAA,GAAA,yCAAA,GACjB,OAAO,0CAAc,OAAO,MAAM,GAAG,OAAO,GAAG;IAEjD,IAAI,CAAC,MAAM,kCAAY,KAAK,CAAC,IAAI,IAAI;QACnC,IAAI,OAAO;QACX,MAAM,YAAY;YAAC,KAAK,CAAC,IAAI;SAAC;QAC9B,MAAO,CAAC,MAAM,kCAAY,KAAK,CAAC,EAAE,KAAK,GACrC,UAAU,IAAI,CAAC,KAAK,CAAC,KAAK;QAE5B,UAAU;QACV,gCAAgC;QAChC,mCAAmC;QACnC,IAAI;QACJ,IAAI,KAAK,CAAC,KAAK,KAAK,CAAA,GAAA,yCAAI,GACtB,MAAM,IAAI,MAAM;QAElB,EAAE;QACF,MAAM,UAAU,OAAO,IAAI,CAAC,WAAW,QAAQ,CAAC;QAChD,MAAM,UAAU,OAAO,QAAQ,CAAC,SAAS;QACzC,MAAM,WAAW,EAAE;QACnB,IAAI,MAAM;QACV,MAAO,QAAQ,QACb,SAAS,IAAI,CAAC,KAAK,CAAC,OAAO;QAE7B,OAAO,0CAAc,OAAO,MAAM,OAAO,GAAG,CAAC,IAAI,CAAA,GAAA,yCAAO,EAAE;IAC5D;IACA,IAAI,KAAK,CAAC,IAAI,KAAK,CAAA,GAAA,yCAAA,GAAG;QACpB,IAAI,OAAO,MAAM;QACjB,MAAM,WAAW,EAAE;QACnB,IAAI,KAAK,CAAC,KAAK,KAAK,CAAA,GAAA,yCAAK,GACvB,SAAS,IAAI,CAAC,KAAK,CAAC,OAAO;QAE7B,MAAO,KAAK,CAAC,KAAK,KAAK,CAAA,GAAA,yCAAA,KAAK,OAAO,MAAM,MAAM,CAAE;YAC/C,MAAM,OAAO,KAAK,CAAC,OAAO;YAC1B,IAAI,OAAO,CAAA,GAAA,yCAAC,KAAK,OAAO,CAAA,GAAA,yCAAC,GACvB,MAAM,IAAI,MAAM,CAAC,qBAAqB,EAAE,KAAK,CAAC;YAEhD,SAAS,IAAI,CAAC;QAChB;QACA,MAAM,SAAS,OAAO,IAAI,CAAC,UAAU,QAAQ,CAAC;QAC9C,EAAE;QACF,OAAO,0CAAc,OAAO,MAAM,OAAO,GAAG,CAAC,IAAI,CAAA,GAAA,yCAAO,EAAE;IAC5D;IACA,MAAM,IAAI,MAAM;AAClB;;;;;;;;;AOjEO,SAAS,0CAAW,IAAI;IAC7B,MAAM,OAAO,OAAO,IAAI,CAAC,MAAM,IAAI;IACnC,MAAM,QAA+B;QAAC,CAAA,GAAA,yCAAK,EAAE;KAAK;IAClD,KAAK,MAAM,OAAO,KAAM;QACtB,MAAM,SAAS,CAAC,EAAE,IAAI,MAAM,CAAC,CAAC,EAAE,IAAI,CAAC;QACrC,MAAM,IAAI,CAAC,MAAM,IAAI,CAAC,OAAO,IAAI,CAAC,QAAQ;QAC1C,MAAM,MAAM,IAAI,CAAC,IAAI;QACrB,IAAI,OAAO,QAAQ,UAAU;YAC3B,MAAM,SAAS,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;YACzB,MAAM,IAAI,CAAC,MAAM,IAAI,CAAC,OAAO,IAAI,CAAC,QAAQ;QAC5C,OAAO,IAAI,OAAO,QAAQ,UAAU;YAClC,MAAM,WAAW,CAAA,GAAA,yCAAa,EAAE,GAAG,CAAC;YACpC,IAAI,CAAC,UACH,MAAM,IAAI,MAAM,CAAC,aAAa,EAAE,IAAI,CAAC;YAEvC,MAAM,SAAS,CAAC,EAAE,SAAS,MAAM,CAAC,CAAC,CAAC;YACpC,MAAM,IAAI,CAAC,MAAM,IAAI,CAAC,OAAO,IAAI,CAAC,QAAQ;YAC1C,MAAM,IAAI,CAAC;QACb,OACE,MAAM,IAAI,MAAM,CAAC,yBAAyB,EAAE,IAAI,CAAC;IAErD;IACA,MAAM,IAAI,CAAC,CAAA,GAAA,yCAAK,EAAE;IAClB,OAAO,OAAO,IAAI,CAAC,MAAM,IAAI;AAC/B;;;;;AFrBO,SAAS,0CAAK,IAAY;IAC/B,MAAM,WAAW,2BAAgB;IACjC,QAAQ,KAAK,CAAC,CAAC,eAAe,EAAE,SAAS,CAAC;IAC1C,MAAM,UAAU,CAAA,GAAA,yCAAY,EAAE;IAC9B,QAAQ,KAAK,CAAC,CAAC,cAAc,EAAE,QAAQ,CAAC;IACxC,MAAM,SAAS,KAAK,KAAK,CAAC;IAC1B,QAAQ,KAAK,CAAC,CAAC,aAAa,EAAE,KAAK,SAAS,CAAC,QAAQ,MAAM,GAAG,CAAC;IAC/D,MAAM,YAAE,QAAQ,QAAE,IAAI,EAAE,GAAG;IAC3B,MAAM,cAAc,CAAA,GAAA,yCAAS,EAAE;IAC/B,QAAQ,KAAK,CAAC,CAAC,mBAAmB,EAAE,YAAY,CAAC;IACjD,QAAQ,KAAK,CAAC,CAAC,sBAAsB,EAAE,CAAA,GAAA,yCAAY,EAAE,aAAa,CAAC;IACnE,MAAM,SAAS,6BAAkB;IACjC,OAAO,MAAM,CAAC;IACd,MAAM,OAAO,OAAO,MAAM,CAAC;IAC3B,MAAM,UAAU;QACd;YAAC;YAAe;SAAS;QACzB;YAAC;YAAU,KAAK,MAAM;SAAC;QACvB;YAAC;YAAa;SAAK;KACpB,CACE,GAAG,CAAC,CAAC,CAAC,GAAG,EAAE,GAAK,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAC5B,IAAI,CAAC;IACR,OAAO;AACT;;;ANzBO,SAAS;IACd,MAAM,UAAU,QAAQ,IAAI,CAAC,EAAE;IAE/B,OAAQ;QACN,KAAK;YAAU;gBACb,MAAM,gBAAgB,QAAQ,IAAI,CAAC,EAAE;gBACrC,MAAM,QAAQ,OAAO,IAAI,CAAC,eAAe;gBACzC,QAAQ,GAAG,CAAC,OAAO,CAAA,GAAA,yCAAY,EAAE;gBACjC;YACF;QACA,KAAK;YAAQ;gBACX,MAAM,OAAO,QAAQ,IAAI,CAAC,EAAE;gBAC5B,QAAQ,GAAG,CAAC,CAAA,GAAA,yCAAG,EAAE;gBACjB;YACF;QACA;YACE,MAAM,IAAI,MAAM;IACpB;AACF;;;;;AFnBA,CAAA,GAAA,yCAAG","sources":["src/main.ts","src/cli/index.ts","src/cli/main.ts","src/decode/decode.ts","src/decode/token-stream.ts","src/decode/tokens.ts","src/hack.ts","src/decode/utils.ts","src/info/info.ts","src/decode/index.ts","src/info/encode-dict.ts"],"sourcesContent":["import { main } from './cli';\n\nmain();\n","export { main } from './main';\n","import { decodeBencode } from '../decode/decode';\nimport { info } from '../info/info';\n\nexport function main() {\n  const command = process.argv[2];\n\n  switch (command) {\n    case 'decode': {\n      const bencodedValue = process.argv[3];\n      const bytes = Buffer.from(bencodedValue, 'utf8');\n      console.log(String(decodeBencode(bytes)));\n      break;\n    }\n    case 'info': {\n      const file = process.argv[3];\n      console.log(info(file));\n      break;\n    }\n    default:\n      throw new Error('Not implemented');\n  }\n}\n","import { TokenStream } from './token-stream';\nimport { OpenDictToken, OpenArrayToken, StrToken, IntToken } from './tokens';\nimport { D, L, E, COLON, I, HYPHEN, $0, $9 } from './utils';\n\nconst intFromByte = (b) => Number.parseInt(String.fromCharCode(b), 10);\n\n// Examples:\n// - decodeBencode(\"5:hello\") -> \"hello\"\n// - decodeBencode(\"10:hello12345\") -> \"hello12345\"\n// - l5:helloi52ee -> [\"hello\", 52]\nexport function decodeBencode(bytes, idx = 0, tokens = new TokenStream()) {\n  if (idx > bytes.length) {\n    console.error(`>>> ERROR: idx ${idx} > ${bytes.length}`);\n    return tokens.bailStr(); // lol - not handling bytes correctly in some sample files?\n  }\n  if (idx === bytes.length) {\n    return tokens;\n  }\n  if (bytes[idx] === D) {\n    return decodeBencode(bytes, idx + 1, tokens.add(new OpenDictToken()));\n  }\n  if (bytes[idx] === L) {\n    return decodeBencode(bytes, idx + 1, tokens.add(new OpenArrayToken()));\n  }\n  if (bytes[idx] === E) {\n    return decodeBencode(bytes, idx + 1, tokens.end());\n  }\n  if (!isNaN(intFromByte(bytes[idx]))) {\n    let next = idx;\n    const sizeBytes = [bytes[idx]];\n    while (!isNaN(intFromByte(bytes[++next]))) {\n      sizeBytes.push(bytes[next]);\n    }\n    // // ????\n    // if (!bytes[next] === COLON) {\n    //   throw new Error('expected :');\n    // }\n    if (bytes[next] !== COLON) {\n      throw new Error('expected :');\n    }\n    ++next;\n    const sizeStr = Buffer.from(sizeBytes).toString('utf8');\n    const sizeNum = Number.parseInt(sizeStr, 10);\n    const strBytes = [];\n    let ate = 0;\n    while (ate++ < sizeNum) {\n      strBytes.push(bytes[next++]);\n    }\n    return decodeBencode(bytes, next, tokens.add(new StrToken(strBytes)));\n  }\n  if (bytes[idx] === I) {\n    let next = idx + 1;\n    const numBytes = [];\n    if (bytes[next] === HYPHEN) {\n      numBytes.push(bytes[next++]);\n    }\n    while (bytes[next] !== E && next < bytes.length) {\n      const numB = bytes[next++];\n      if (numB < $0 || numB > $9) {\n        throw new Error(`invalid integer byte ${numB}`);\n      }\n      numBytes.push(numB);\n    }\n    const numStr = Buffer.from(numBytes).toString('utf8');\n    ++next;\n    return decodeBencode(bytes, next, tokens.add(new IntToken(numStr)));\n  }\n  throw new Error('Unknown token type');\n}\n","import {\n  CloseArrayToken,\n  CloseDictToken,\n  KvSeparatorToken,\n  OpenArrayToken,\n  OpenDictToken,\n  SeparatorToken,\n  StrToken,\n  Token,\n} from './tokens';\n\nexport class TokenStream {\n  constructor(\n    readonly tokens: Token[] = [],\n    readonly openDelims: Token[] = [],\n  ) {\n    this.openDelims = openDelims ?? [];\n    this.tokens = tokens ?? [];\n  }\n\n  end() {\n    const top = this.openDelims.at(-1);\n    if (top instanceof OpenArrayToken) {\n      return this.add(new CloseArrayToken());\n    }\n    if (top instanceof OpenDictToken) {\n      return this.add(new CloseDictToken());\n    }\n    throw new Error('unexpected end');\n  }\n\n  bailStr() {\n    if (!this.openDelims.length) {\n      return this.toString();\n    }\n    return this.end().bailStr();\n  }\n\n  add(t) {\n    let nextDelims = this.openDelims;\n    if (t instanceof OpenArrayToken) {\n      nextDelims = nextDelims.concat(t);\n    } else if (t instanceof OpenDictToken) {\n      nextDelims = nextDelims.concat(t);\n    } else if (t instanceof CloseArrayToken) {\n      const top = nextDelims.at(-1);\n      if (!(top instanceof OpenArrayToken)) {\n        throw new Error('unmatched close array token');\n      }\n      nextDelims = [...nextDelims];\n      nextDelims.pop();\n    } else if (t instanceof CloseDictToken) {\n      const top = nextDelims.at(-1);\n      if (!(top instanceof OpenDictToken)) {\n        throw new Error('unmatched close dict token');\n      }\n      nextDelims = [...nextDelims];\n      nextDelims.pop();\n    }\n\n    const needsArrSep =\n      this.openDelims.at(-1) instanceof OpenArrayToken &&\n      !(t instanceof CloseArrayToken) &&\n      !(this.tokens.at(-1) instanceof OpenArrayToken);\n\n    const needsKvSep =\n      this.openDelims.at(-1) instanceof OpenDictToken &&\n      this.tokens.at(-1) instanceof StrToken &&\n      !(this.tokens.at(-2) instanceof KvSeparatorToken);\n\n    const needsDictSep =\n      !needsKvSep &&\n      this.openDelims.at(-1) instanceof OpenDictToken &&\n      !(t instanceof CloseDictToken) &&\n      !(this.tokens.at(-1) instanceof OpenDictToken);\n\n    if (needsArrSep && needsDictSep) {\n      throw new Error('cannot need both');\n    }\n    if (needsKvSep && (needsDictSep || needsArrSep)) {\n      throw new Error('cannot need kv and dict/arr sep');\n    }\n\n    const nextTokens =\n      needsArrSep || needsDictSep\n        ? this.tokens.concat(new SeparatorToken())\n        : needsKvSep\n          ? this.tokens.concat(new KvSeparatorToken())\n          : this.tokens;\n\n    return new TokenStream(nextTokens.concat(t), nextDelims);\n  }\n\n  toString() {\n    const raw = this.tokens.join('');\n    const parsed = JSON.parse(raw);\n    const str = JSON.stringify(parsed);\n    return str;\n  }\n}\n","import { hackStrToBytes } from '../hack';\n\nexport class Token {\n  constructor(readonly str?: string) {}\n\n  toString() {\n    return this.str;\n  }\n}\n\nexport class IntToken extends Token {}\n\nexport class StrToken extends Token {\n  readonly buffer: Buffer;\n  constructor(strBytes) {\n    const buffer = Buffer.from(strBytes);\n    const str = buffer.toString('utf8');\n    hackStrToBytes.set(str, strBytes);\n    super(str);\n    this.buffer = buffer;\n  }\n  toString() {\n    return JSON.stringify(this.str);\n  }\n}\n\nexport class OpenArrayToken extends Token {\n  toString() {\n    return `[`;\n  }\n}\n\nexport class CloseArrayToken extends Token {\n  toString() {\n    return `]`;\n  }\n}\n\nexport class OpenDictToken extends Token {\n  toString() {\n    return `{`;\n  }\n}\n\nexport class CloseDictToken extends Token {\n  toString() {\n    return `}`;\n  }\n}\n\nexport class SeparatorToken extends Token {\n  toString() {\n    return `, `;\n  }\n}\n\nexport class KvSeparatorToken extends Token {\n  toString() {\n    return `: `;\n  }\n}\n","// serialization issues when round tripping bytes to \"chars\" to bytes\n// keep the original bytes for the string\n// TODO: could maybe get away with a WeakRef here\nexport const hackStrToBytes = new Map();\n","export const asByte = (ch: string) => ch.charCodeAt(0);\n\nexport const I = asByte('i');\nexport const E = asByte('e');\nexport const COLON = asByte(':');\nexport const HYPHEN = asByte('-');\nexport const $0 = asByte('0');\nexport const $9 = asByte('9');\nexport const L = asByte('l');\nexport const D = asByte('d');\n","const crypto = require('node:crypto');\nconst fs = require('node:fs');\n\nimport { decodeBencode } from '../decode';\nimport { encodeDict } from './encode-dict';\n\nexport function info(file: string) {\n  const contents = fs.readFileSync(file);\n  console.error(`>>> contents:\\n${contents}`);\n  const decoded = decodeBencode(contents);\n  console.error(`>>> decoded:\\n${decoded}`);\n  const parsed = JSON.parse(decoded);\n  console.error(`>>> parsed:\\n${JSON.stringify(parsed, null, 2)}`);\n  const { announce, info } = parsed;\n  const encodedInfo = encodeDict(info);\n  console.error(`>>> encoded info:\\n${encodedInfo}`);\n  console.error(`>>> round-trip info:\\n${decodeBencode(encodedInfo)}`);\n  const hasher = crypto.createHash('sha1');\n  hasher.update(encodedInfo);\n  const sha1 = hasher.digest('hex');\n  const infoStr = [\n    ['Tracker URL', announce],\n    ['Length', info.length],\n    ['Info Hash', sha1],\n  ]\n    .map(([k, v]) => `${k}: ${v}`)\n    .join('\\n');\n  return infoStr;\n}\n","export { decodeBencode } from './decode';\nexport * from './utils';\n","import { asByte } from '../decode';\nimport { hackStrToBytes } from '../hack';\n\nexport function encodeDict(dict) {\n  const keys = Object.keys(dict).sort();\n  const bytes: (number | number[])[] = [asByte('d')];\n  for (const key of keys) {\n    const keyStr = `${key.length}:${key}`;\n    bytes.push(Array.from(Buffer.from(keyStr, 'utf8')));\n    const val = dict[key];\n    if (typeof val === 'number') {\n      const intStr = `i${val}e`;\n      bytes.push(Array.from(Buffer.from(intStr, 'utf8')));\n    } else if (typeof val === 'string') {\n      const strBytes = hackStrToBytes.get(val);\n      if (!strBytes) {\n        throw new Error(`no bytes for ${val}`);\n      }\n      const prefix = `${strBytes.length}:`;\n      bytes.push(Array.from(Buffer.from(prefix, 'utf8')));\n      bytes.push(strBytes);\n    } else {\n      throw new Error(`unsupported val type for ${val}`);\n    }\n  }\n  bytes.push(asByte('e'));\n  return Buffer.from(bytes.flat());\n}\n"],"names":[],"version":3,"file":"main.js.map","sourceRoot":"../"}