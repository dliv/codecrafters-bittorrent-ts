{"mappings":"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","sources":["src/main.ts","src/cli/index.ts","src/cli/main.ts","src/decode/index.ts","src/decode/decode.ts","src/decode/token-stream.ts","src/decode/tokens.ts","src/hack.ts","src/decode/utils.ts","src/info/index.ts","src/info/info.ts","src/info/encode-dict.ts","src/peers/index.ts","src/peers/peers.ts","src/peers/http-get-buffer.ts"],"sourcesContent":["import { main } from './cli';\n\nmain().catch((e) => {\n  console.error(e);\n  process.exit(1);\n});\n","export { main } from './main';\n","import { decodeCommand } from '../decode';\nimport { infoCommand } from '../info';\nimport { peersCommand } from '../peers';\n\nexport async function main() {\n  const command = process.argv[2];\n\n  switch (command) {\n    case 'decode': {\n      const bencodedValue = process.argv[3];\n      console.log(decodeCommand(bencodedValue));\n      break;\n    }\n    case 'info': {\n      const file = process.argv[3];\n      console.log(infoCommand(file));\n      break;\n    }\n    case 'peers': {\n      const file = process.argv[3];\n      console.log(await peersCommand(file));\n      break;\n    }\n    default:\n      throw new Error('Not implemented');\n  }\n}\n","export { decodeBencode, decodeCommand } from './decode';\nexport * from './utils';\n","import { TokenStream } from './token-stream';\nimport { OpenDictToken, OpenArrayToken, StrToken, IntToken } from './tokens';\nimport { D, L, E, COLON, I, HYPHEN, $0, $9 } from './utils';\n\nconst intFromByte = (b: number) => Number.parseInt(String.fromCharCode(b), 10);\n\nexport function decodeCommand(str: string): string {\n  const bytes = Buffer.from(str, 'utf8');\n  const decoded = String(decodeBencode(bytes));\n  return decoded;\n}\n\n// Examples:\n// - decodeBencode(\"5:hello\") -> \"hello\"\n// - decodeBencode(\"10:hello12345\") -> \"hello12345\"\n// - l5:helloi52ee -> [\"hello\", 52]\nexport function decodeBencode(bytes, idx = 0, tokens = new TokenStream()) {\n  if (idx > bytes.length) {\n    console.error(`>>> ERROR: idx ${idx} > ${bytes.length}`);\n    return tokens.bailStr(); // lol - not handling bytes correctly in some sample files?\n  }\n  if (idx === bytes.length) {\n    return tokens;\n  }\n  if (bytes[idx] === D) {\n    return decodeBencode(bytes, idx + 1, tokens.add(new OpenDictToken()));\n  }\n  if (bytes[idx] === L) {\n    return decodeBencode(bytes, idx + 1, tokens.add(new OpenArrayToken()));\n  }\n  if (bytes[idx] === E) {\n    return decodeBencode(bytes, idx + 1, tokens.end());\n  }\n  if (!isNaN(intFromByte(bytes[idx]))) {\n    let next = idx;\n    const sizeBytes = [bytes[idx]];\n    while (!isNaN(intFromByte(bytes[++next]))) {\n      sizeBytes.push(bytes[next]);\n    }\n    // // ????\n    // if (!bytes[next] === COLON) {\n    //   throw new Error('expected :');\n    // }\n    if (bytes[next] !== COLON) {\n      throw new Error('expected :');\n    }\n    ++next;\n    const sizeStr = Buffer.from(sizeBytes).toString('utf8');\n    const sizeNum = Number.parseInt(sizeStr, 10);\n    const strBytes = [];\n    let ate = 0;\n    while (ate++ < sizeNum) {\n      strBytes.push(bytes[next++]);\n    }\n    return decodeBencode(bytes, next, tokens.add(new StrToken(strBytes)));\n  }\n  if (bytes[idx] === I) {\n    let next = idx + 1;\n    const numBytes = [];\n    if (bytes[next] === HYPHEN) {\n      numBytes.push(bytes[next++]);\n    }\n    while (bytes[next] !== E && next < bytes.length) {\n      const numB = bytes[next++];\n      if (numB < $0 || numB > $9) {\n        throw new Error(`invalid integer byte ${numB}`);\n      }\n      numBytes.push(numB);\n    }\n    const numStr = Buffer.from(numBytes).toString('utf8');\n    ++next;\n    return decodeBencode(bytes, next, tokens.add(new IntToken(numStr)));\n  }\n  throw new Error(`Unknown token type at index ${idx}`);\n}\n","import {\n  CloseArrayToken,\n  CloseDictToken,\n  KvSeparatorToken,\n  OpenArrayToken,\n  OpenDictToken,\n  SeparatorToken,\n  StrToken,\n  Token,\n} from './tokens';\n\nexport class TokenStream {\n  constructor(\n    readonly tokens: Token[] = [],\n    readonly openDelims: Token[] = [],\n  ) {\n    this.openDelims = openDelims ?? [];\n    this.tokens = tokens ?? [];\n  }\n\n  end() {\n    const top = this.openDelims.at(-1);\n    if (top instanceof OpenArrayToken) {\n      return this.add(new CloseArrayToken());\n    }\n    if (top instanceof OpenDictToken) {\n      return this.add(new CloseDictToken());\n    }\n    throw new Error('unexpected end');\n  }\n\n  bailStr() {\n    if (!this.openDelims.length) {\n      return this.toString();\n    }\n    return this.end().bailStr();\n  }\n\n  add(t) {\n    let nextDelims = this.openDelims;\n    if (t instanceof OpenArrayToken) {\n      nextDelims = nextDelims.concat(t);\n    } else if (t instanceof OpenDictToken) {\n      nextDelims = nextDelims.concat(t);\n    } else if (t instanceof CloseArrayToken) {\n      const top = nextDelims.at(-1);\n      if (!(top instanceof OpenArrayToken)) {\n        throw new Error('unmatched close array token');\n      }\n      nextDelims = [...nextDelims];\n      nextDelims.pop();\n    } else if (t instanceof CloseDictToken) {\n      const top = nextDelims.at(-1);\n      if (!(top instanceof OpenDictToken)) {\n        throw new Error('unmatched close dict token');\n      }\n      nextDelims = [...nextDelims];\n      nextDelims.pop();\n    }\n\n    const needsArrSep =\n      this.openDelims.at(-1) instanceof OpenArrayToken &&\n      !(t instanceof CloseArrayToken) &&\n      !(this.tokens.at(-1) instanceof OpenArrayToken);\n\n    const needsKvSep =\n      this.openDelims.at(-1) instanceof OpenDictToken &&\n      this.tokens.at(-1) instanceof StrToken &&\n      !(this.tokens.at(-2) instanceof KvSeparatorToken);\n\n    const needsDictSep =\n      !needsKvSep &&\n      this.openDelims.at(-1) instanceof OpenDictToken &&\n      !(t instanceof CloseDictToken) &&\n      !(this.tokens.at(-1) instanceof OpenDictToken);\n\n    if (needsArrSep && needsDictSep) {\n      throw new Error('cannot need both');\n    }\n    if (needsKvSep && (needsDictSep || needsArrSep)) {\n      throw new Error('cannot need kv and dict/arr sep');\n    }\n\n    const nextTokens =\n      needsArrSep || needsDictSep\n        ? this.tokens.concat(new SeparatorToken())\n        : needsKvSep\n          ? this.tokens.concat(new KvSeparatorToken())\n          : this.tokens;\n\n    return new TokenStream(nextTokens.concat(t), nextDelims);\n  }\n\n  toString() {\n    const raw = this.tokens.join('');\n    const parsed = JSON.parse(raw);\n    const str = JSON.stringify(parsed);\n    return str;\n  }\n}\n","import { hackStrToBytes } from '../hack';\n\nexport class Token {\n  constructor(readonly str?: string) {}\n\n  toString() {\n    return this.str;\n  }\n}\n\nexport class IntToken extends Token {}\n\nexport class StrToken extends Token {\n  readonly buffer: Buffer;\n  constructor(strBytes) {\n    const buffer = Buffer.from(strBytes);\n    const str = buffer.toString('utf8');\n    hackStrToBytes.set(str, strBytes);\n    super(str);\n    this.buffer = buffer;\n  }\n  toString() {\n    return JSON.stringify(this.str);\n  }\n}\n\nexport class OpenArrayToken extends Token {\n  toString() {\n    return `[`;\n  }\n}\n\nexport class CloseArrayToken extends Token {\n  toString() {\n    return `]`;\n  }\n}\n\nexport class OpenDictToken extends Token {\n  toString() {\n    return `{`;\n  }\n}\n\nexport class CloseDictToken extends Token {\n  toString() {\n    return `}`;\n  }\n}\n\nexport class SeparatorToken extends Token {\n  toString() {\n    return `, `;\n  }\n}\n\nexport class KvSeparatorToken extends Token {\n  toString() {\n    return `: `;\n  }\n}\n","// serialization issues when round tripping bytes to \"chars\" to bytes\n// keep the original bytes for the string\n// TODO: could maybe get away with a WeakRef here\nexport const hackStrToBytes = new Map();\n","export const asByte = (ch: string) => ch.charCodeAt(0);\n\nexport const I = asByte('i');\nexport const E = asByte('e');\nexport const COLON = asByte(':');\nexport const HYPHEN = asByte('-');\nexport const $0 = asByte('0');\nexport const $9 = asByte('9');\nexport const L = asByte('l');\nexport const D = asByte('d');\n","export { getInfo, infoCommand } from './info';\n","import crypto from 'node:crypto';\nimport fs from 'node:fs';\n\nimport { decodeBencode } from '../decode';\nimport { hackStrToBytes } from '../hack';\nimport { encodeDict } from './encode-dict';\n\nexport const getInfo = (file: string) => {\n  const contents = fs.readFileSync(file);\n  const decoded = decodeBencode(contents);\n  const parsed = JSON.parse(decoded);\n  const { announce, info } = parsed;\n  const encodedInfo = encodeDict(info);\n  const hasher = crypto.createHash('sha1');\n  hasher.update(encodedInfo);\n  const sha1 = hasher.digest('hex');\n  const hasherRaw = crypto.createHash('sha1');\n  hasherRaw.update(encodedInfo);\n  const sha1Raw = hasherRaw.digest();\n\n  const piecesConcat = hackStrToBytes.get(info.pieces);\n  const pieceHashes: string[] = [];\n  for (let i = 0; i < piecesConcat.length; i += 20) {\n    const p = piecesConcat.slice(i, i + 20);\n    pieceHashes.push(Buffer.from(p).toString('hex'));\n  }\n\n  return {\n    announce,\n    info,\n    sha1,\n    sha1Raw,\n    pieceHashes,\n  };\n};\n\nexport function infoCommand(file: string) {\n  const { announce, info, sha1, pieceHashes } = getInfo(file);\n  const infoStr = [\n    ['Tracker URL', announce],\n    ['Length', info.length],\n    ['Info Hash', sha1],\n    ['Piece Length', info['piece length']],\n    ['Piece Hashes', pieceHashes.join('\\n'), '\\n'],\n  ]\n    .map(([k, v, delim = ' ']) => `${k}:${delim}${v}`)\n    .join('\\n');\n  return infoStr;\n}\n","import { asByte } from '../decode';\nimport { hackStrToBytes } from '../hack';\n\nexport function encodeDict(dict) {\n  const keys = Object.keys(dict).sort();\n  const bytes: (number | number[])[] = [asByte('d')];\n  for (const key of keys) {\n    const keyStr = `${key.length}:${key}`;\n    bytes.push(Array.from(Buffer.from(keyStr, 'utf8')));\n    const val = dict[key];\n    if (typeof val === 'number') {\n      const intStr = `i${val}e`;\n      bytes.push(Array.from(Buffer.from(intStr, 'utf8')));\n    } else if (typeof val === 'string') {\n      const strBytes = hackStrToBytes.get(val);\n      if (!strBytes) {\n        throw new Error(`no bytes for ${val}`);\n      }\n      const prefix = `${strBytes.length}:`;\n      bytes.push(Array.from(Buffer.from(prefix, 'utf8')));\n      bytes.push(strBytes);\n    } else {\n      throw new Error(`unsupported val type for ${val}`);\n    }\n  }\n  bytes.push(asByte('e'));\n  return Buffer.from(bytes.flat());\n}\n","export { peersCommand } from './peers';\n","import { decodeBencode } from '../decode';\nimport { hackStrToBytes } from '../hack';\nimport { getInfo } from '../info';\nimport { httpGetBuffer } from './http-get-buffer';\n\nconst peerId = 'a79a7e603a3d4357b52f';\nconst PORT = '6881';\n\nexport async function peersCommand(file: string) {\n  const peersResp = await peers(file);\n  return peersResp.peers.join('\\n');\n}\n\nexport async function peers(file: string) {\n  const info = getInfo(file);\n  const url = getPeersUrl(info);\n  const respStr = await httpGetBuffer(url);\n  const decoded = decodePeersResp(respStr);\n  return decoded;\n}\n\n// exported for testing\nexport function decodePeersResp(resp: Buffer) {\n  const { interval, peers } = JSON.parse(String(decodeBencode(resp)));\n  const peersBytes = hackStrToBytes.get(peers);\n  const peerStrs: string[] = [];\n  for (let i = 0; i < peersBytes.length; i += 6) {\n    const ip = peersBytes.slice(i, i + 4).join('.');\n    const [p0, p1] = peersBytes.slice(i + 4, i + 6);\n    const port = (p0 << 8) | p1;\n    const str = [ip, port].join(':');\n    peerStrs.push(str);\n  }\n  return { interval, peers: peerStrs };\n}\n\nfunction getPeersUrl(info): string {\n  const infoHashBuf = Buffer.from(info.sha1, 'hex');\n  if (infoHashBuf.length !== 20) {\n    throw new Error('infoHashRaw.length !== 20');\n  }\n\n  const params = new URLSearchParams();\n  params.append('peer_id', peerId);\n  params.append('port', PORT);\n  params.append('uploaded', '0');\n  params.append('downloaded', '0');\n  params.append('left', info.info.length.toString());\n  params.append('compact', '1');\n\n  let url = `${info.announce}?${params.toString()}`;\n  url += `&info_hash=${encodeInfoHash(info.sha1)}`;\n  return url;\n}\n\n// exported for testing\nexport function encodeInfoHash(hexStr: string): string {\n  const encoded: string[] = [];\n  for (let i = 0; i < hexStr.length; i += 2) {\n    const pair = hexStr.slice(i, i + 2);\n    let e = '';\n    switch (pair.toLowerCase()) {\n      case '4c':\n        e = 'L';\n        break;\n      case '54':\n        e = 'T';\n        break;\n      case '68':\n        e = 'h';\n        break;\n      case '71':\n        e = 'q';\n        break;\n      default:\n        e = `%${pair}`;\n    }\n    encoded.push(e);\n  }\n  return encoded.join('');\n}\n","import http from 'node:http';\nimport url from 'node:url';\n\nexport function httpGetBuffer(\n  requestUrl: string,\n  maxRedirects = 7,\n): Promise<Buffer> {\n  return new Promise((resolve, reject) => {\n    http\n      .get(requestUrl, (res) => {\n        const isRedirect = res.statusCode === 301 || res.statusCode === 302;\n        if (isRedirect && maxRedirects < 1) {\n          return reject(new Error('Too many redirects'));\n        } else if (isRedirect) {\n          const newLocation = res.headers.location;\n          const newUrl =\n            newLocation.startsWith('http://') ||\n            newLocation.startsWith('https://')\n              ? newLocation\n              : new url.URL(newLocation, requestUrl).href;\n          return httpGetBuffer(newUrl, maxRedirects - 1)\n            .then(resolve)\n            .catch(reject);\n        }\n\n        if (res.statusCode < 200 || res.statusCode >= 300) {\n          return reject(\n            new Error('StatusCode=' + res.statusCode + ` url=${url}`),\n          );\n        }\n\n        const chunks = [];\n\n        res.on('data', (chunk) => {\n          chunks.push(chunk);\n        });\n\n        res.on('end', () => {\n          const buffer = Buffer.concat(chunks);\n          resolve(buffer);\n        });\n      })\n      .on('error', (err) => {\n        reject(err);\n      });\n  });\n}\n"],"names":[],"version":3,"file":"main.js.map","sourceRoot":"../"}