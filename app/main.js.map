{"mappings":"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","sources":["src/main.ts","src/cli/index.ts","src/cli/main.ts","src/decode/index.ts","src/decode/decode.ts","src/decode/token-stream.ts","src/decode/tokens.ts","src/hack.ts","src/decode/utils.ts","src/download_piece/index.ts","src/download_piece/download-piece.ts","src/info/index.ts","src/info/info.ts","src/info/encode-dict.ts","src/peers/index.ts","src/peers/peers.ts","src/peers/http-get-buffer.ts","src/peers/peer-connection.ts","src/handshake/utils.ts","src/peers/message.ts","src/peers/utils.ts","src/download_piece/util.ts","src/handshake/index.ts","src/handshake/handshake.ts"],"sourcesContent":["import { main } from './cli';\n\nmain().catch((e) => {\n  console.error(e);\n  process.exit(1);\n});\n","export { main } from './main';\n","import { decodeCommand } from '../decode';\nimport { downloadPieceCommand } from '../download_piece';\nimport { handshakeCommand } from '../handshake';\nimport { infoCommand } from '../info';\nimport { peersCommand } from '../peers';\n\nexport async function main() {\n  const command = process.argv[2];\n\n  switch (command) {\n    case 'decode': {\n      const bencodedValue = process.argv[3];\n      console.log(decodeCommand(bencodedValue));\n      break;\n    }\n    case 'info': {\n      const file = process.argv[3];\n      console.log(infoCommand(file));\n      break;\n    }\n    case 'peers': {\n      const file = process.argv[3];\n      console.log(await peersCommand(file));\n      break;\n    }\n    case 'handshake': {\n      const file = process.argv[3];\n      const peer = process.argv[4];\n      console.log(await handshakeCommand(file, peer));\n      break;\n    }\n    case 'download_piece': {\n      const flag = process.argv[3];\n      const saveFile = process.argv[4];\n      const torrentFile = process.argv[5];\n      const piece = process.argv[6];\n      if (flag !== '-o') {\n        throw new Error(`Expected flag -o, got ${flag}`);\n      }\n      const pieceNum: number = Number.parseInt(piece, 10);\n      if (!(Number.isSafeInteger(pieceNum) && pieceNum >= 0)) {\n        throw new Error(`bad piece: ${piece}`);\n      }\n      console.log(await downloadPieceCommand(saveFile, torrentFile, pieceNum));\n      break;\n    }\n    default:\n      throw new Error(`Unknown command: ${command}`);\n  }\n}\n","export { decodeBencode, decodeCommand } from './decode';\nexport * from './utils';\n","import { TokenStream } from './token-stream';\nimport { OpenDictToken, OpenArrayToken, StrToken, IntToken } from './tokens';\nimport { D, L, E, COLON, I, HYPHEN, $0, $9 } from './utils';\n\nconst intFromByte = (b: number) => Number.parseInt(String.fromCharCode(b), 10);\n\nexport function decodeCommand(str: string): string {\n  const bytes = Buffer.from(str, 'utf8');\n  const decoded = String(decodeBencode(bytes));\n  return decoded;\n}\n\n// Examples:\n// - decodeBencode(\"5:hello\") -> \"hello\"\n// - decodeBencode(\"10:hello12345\") -> \"hello12345\"\n// - l5:helloi52ee -> [\"hello\", 52]\nexport function decodeBencode(bytes, idx = 0, tokens = new TokenStream()) {\n  if (idx > bytes.length) {\n    console.error(`>>> ERROR: idx ${idx} > ${bytes.length}`);\n    return tokens.bailStr(); // lol - not handling bytes correctly in some sample files?\n  }\n  if (idx === bytes.length) {\n    return tokens;\n  }\n  if (bytes[idx] === D) {\n    return decodeBencode(bytes, idx + 1, tokens.add(new OpenDictToken()));\n  }\n  if (bytes[idx] === L) {\n    return decodeBencode(bytes, idx + 1, tokens.add(new OpenArrayToken()));\n  }\n  if (bytes[idx] === E) {\n    return decodeBencode(bytes, idx + 1, tokens.end());\n  }\n  if (!isNaN(intFromByte(bytes[idx]))) {\n    let next = idx;\n    const sizeBytes = [bytes[idx]];\n    while (!isNaN(intFromByte(bytes[++next]))) {\n      sizeBytes.push(bytes[next]);\n    }\n    // // ????\n    // if (!bytes[next] === COLON) {\n    //   throw new Error('expected :');\n    // }\n    if (bytes[next] !== COLON) {\n      throw new Error('expected :');\n    }\n    ++next;\n    const sizeStr = Buffer.from(sizeBytes).toString('utf8');\n    const sizeNum = Number.parseInt(sizeStr, 10);\n    const strBytes = [];\n    let ate = 0;\n    while (ate++ < sizeNum) {\n      strBytes.push(bytes[next++]);\n    }\n    return decodeBencode(bytes, next, tokens.add(new StrToken(strBytes)));\n  }\n  if (bytes[idx] === I) {\n    let next = idx + 1;\n    const numBytes = [];\n    if (bytes[next] === HYPHEN) {\n      numBytes.push(bytes[next++]);\n    }\n    while (bytes[next] !== E && next < bytes.length) {\n      const numB = bytes[next++];\n      if (numB < $0 || numB > $9) {\n        throw new Error(`invalid integer byte ${numB}`);\n      }\n      numBytes.push(numB);\n    }\n    const numStr = Buffer.from(numBytes).toString('utf8');\n    ++next;\n    return decodeBencode(bytes, next, tokens.add(new IntToken(numStr)));\n  }\n  throw new Error(`Unknown token type at index ${idx}`);\n}\n","import {\n  CloseArrayToken,\n  CloseDictToken,\n  KvSeparatorToken,\n  OpenArrayToken,\n  OpenDictToken,\n  SeparatorToken,\n  StrToken,\n  Token,\n} from './tokens';\n\nexport class TokenStream {\n  constructor(\n    readonly tokens: Token[] = [],\n    readonly openDelims: Token[] = [],\n  ) {\n    this.openDelims = openDelims ?? [];\n    this.tokens = tokens ?? [];\n  }\n\n  end() {\n    const top = this.openDelims.at(-1);\n    if (top instanceof OpenArrayToken) {\n      return this.add(new CloseArrayToken());\n    }\n    if (top instanceof OpenDictToken) {\n      return this.add(new CloseDictToken());\n    }\n    throw new Error('unexpected end');\n  }\n\n  bailStr() {\n    if (!this.openDelims.length) {\n      return this.toString();\n    }\n    return this.end().bailStr();\n  }\n\n  add(t) {\n    let nextDelims = this.openDelims;\n    if (t instanceof OpenArrayToken) {\n      nextDelims = nextDelims.concat(t);\n    } else if (t instanceof OpenDictToken) {\n      nextDelims = nextDelims.concat(t);\n    } else if (t instanceof CloseArrayToken) {\n      const top = nextDelims.at(-1);\n      if (!(top instanceof OpenArrayToken)) {\n        throw new Error('unmatched close array token');\n      }\n      nextDelims = [...nextDelims];\n      nextDelims.pop();\n    } else if (t instanceof CloseDictToken) {\n      const top = nextDelims.at(-1);\n      if (!(top instanceof OpenDictToken)) {\n        throw new Error('unmatched close dict token');\n      }\n      nextDelims = [...nextDelims];\n      nextDelims.pop();\n    }\n\n    const needsArrSep =\n      this.openDelims.at(-1) instanceof OpenArrayToken &&\n      !(t instanceof CloseArrayToken) &&\n      !(this.tokens.at(-1) instanceof OpenArrayToken);\n\n    const needsKvSep =\n      this.openDelims.at(-1) instanceof OpenDictToken &&\n      this.tokens.at(-1) instanceof StrToken &&\n      !(this.tokens.at(-2) instanceof KvSeparatorToken);\n\n    const needsDictSep =\n      !needsKvSep &&\n      this.openDelims.at(-1) instanceof OpenDictToken &&\n      !(t instanceof CloseDictToken) &&\n      !(this.tokens.at(-1) instanceof OpenDictToken);\n\n    if (needsArrSep && needsDictSep) {\n      throw new Error('cannot need both');\n    }\n    if (needsKvSep && (needsDictSep || needsArrSep)) {\n      throw new Error('cannot need kv and dict/arr sep');\n    }\n\n    const nextTokens =\n      needsArrSep || needsDictSep\n        ? this.tokens.concat(new SeparatorToken())\n        : needsKvSep\n          ? this.tokens.concat(new KvSeparatorToken())\n          : this.tokens;\n\n    return new TokenStream(nextTokens.concat(t), nextDelims);\n  }\n\n  toString() {\n    const raw = this.tokens.join('');\n    const parsed = JSON.parse(raw);\n    const str = JSON.stringify(parsed);\n    return str;\n  }\n}\n","import { hackStrToBytes } from '../hack';\n\nexport class Token {\n  constructor(readonly str?: string) {}\n\n  toString() {\n    return this.str;\n  }\n}\n\nexport class IntToken extends Token {}\n\nexport class StrToken extends Token {\n  readonly buffer: Buffer;\n  constructor(strBytes) {\n    const buffer = Buffer.from(strBytes);\n    const str = buffer.toString('utf8');\n    hackStrToBytes.set(str, strBytes);\n    super(str);\n    this.buffer = buffer;\n  }\n  toString() {\n    return JSON.stringify(this.str);\n  }\n}\n\nexport class OpenArrayToken extends Token {\n  toString() {\n    return `[`;\n  }\n}\n\nexport class CloseArrayToken extends Token {\n  toString() {\n    return `]`;\n  }\n}\n\nexport class OpenDictToken extends Token {\n  toString() {\n    return `{`;\n  }\n}\n\nexport class CloseDictToken extends Token {\n  toString() {\n    return `}`;\n  }\n}\n\nexport class SeparatorToken extends Token {\n  toString() {\n    return `, `;\n  }\n}\n\nexport class KvSeparatorToken extends Token {\n  toString() {\n    return `: `;\n  }\n}\n","// my original decoder assumed we wouldn't need the original bytes again\n// but we do and i'm too lazy to touch the decoder again\n// so this hack allows looking up the original bytes\n// (could maybe use a WeakRef but really the decoder should just be rewritten)\nexport const hackStrToBytes = new Map<string, number[]>();\n","export const asByte = (ch: string) => ch.charCodeAt(0);\n\nexport const I = asByte('i');\nexport const E = asByte('e');\nexport const COLON = asByte(':');\nexport const HYPHEN = asByte('-');\nexport const $0 = asByte('0');\nexport const $9 = asByte('9');\nexport const L = asByte('l');\nexport const D = asByte('d');\n","export { downloadPieceCommand } from './download-piece';\n","import fs from 'node:fs/promises';\n\nimport { getInfo } from '../info';\nimport { peers, PeerConnection } from '../peers';\nimport { sample } from './util';\n\nexport async function downloadPieceCommand(saveFile: string, torrentFile: string, pieceNum: number): Promise<string> {\n  await downloadPiece(saveFile, torrentFile, pieceNum);\n  return `Piece ${pieceNum} downloaded to ${saveFile}.`;\n}\n\nexport async function downloadPiece(saveFile: string, torrentFile: string, pieceNum: number): Promise<void> {\n  const info = getInfo(torrentFile);\n  const peersResp = await peers(torrentFile);\n\n  const peer = sample(peersResp.peers);\n  const conn = new PeerConnection(info, peer);\n\n  try {\n    const piece = await conn.downloadSinglePiece(pieceNum);\n\n    // const piece = await Promise.race(\n    //   peersResp.peers.map(async (peer) => {\n    //     const conn = new PeerConnection(info, peer);\n    //     const piece = await conn.downloadSinglePiece(pieceNum);\n    //     return piece;\n    //   }),\n    // );\n\n    // ideally we could stream the piece into the file but that's more involved\n    // since we validate the sha1. this should be fine since we're only writing a piece at a time\n    await fs.writeFile(saveFile, piece);\n    console.error(`saved piece ${pieceNum} to ${saveFile}`);\n  } finally {\n    conn.close();\n  }\n}\n","export * from './info';\n","import assert from 'node:assert';\nimport crypto from 'node:crypto';\nimport fs from 'node:fs';\n\nimport { decodeBencode } from '../decode';\nimport { hackStrToBytes } from '../hack';\nimport { encodeDict } from './encode-dict';\n\nexport type DecodedTorrentFile = {\n  announce: string;\n  info: {\n    length: number;\n    'piece length': number;\n    pieces: string;\n  };\n};\n\nexport type TorrentInfo = DecodedTorrentFile & {\n  pieceHashes: string[];\n  sha1: string;\n  sha1Raw: Buffer;\n};\n\nexport const getInfo = (file: string): TorrentInfo => {\n  const contents = fs.readFileSync(file);\n  const decoded = decodeBencode(contents);\n  const parsed: DecodedTorrentFile = JSON.parse(decoded);\n  const { announce, info } = parsed;\n  assert(typeof announce === 'string', 'announce is not a string');\n  assert(typeof info === 'object', 'info is not an object');\n  assert(typeof info.length === 'number', 'info.length is not a number');\n  assert(typeof info['piece length'] === 'number', 'info[\"piece length\"] is not a number');\n\n  // this should actually be a Buffer or number[] but my original decoder loses some info\n  // (i.e. is shit) so we need `hackStrToBytes` to look up the original bytes\n  assert(typeof info.pieces === 'string', 'info.pieces is not a string');\n\n  const encodedInfo = encodeDict(info);\n  const hasher = crypto.createHash('sha1');\n  hasher.update(encodedInfo);\n  const sha1 = hasher.digest('hex');\n  const hasherRaw = crypto.createHash('sha1');\n  hasherRaw.update(encodedInfo);\n  const sha1Raw = hasherRaw.digest();\n\n  const piecesConcat = hackStrToBytes.get(info.pieces);\n  const pieceHashes: string[] = [];\n  for (let i = 0; i < piecesConcat.length; i += 20) {\n    const p = piecesConcat.slice(i, i + 20);\n    pieceHashes.push(Buffer.from(p).toString('hex'));\n  }\n\n  const extendedInfo: TorrentInfo = {\n    announce,\n    info,\n    sha1,\n    sha1Raw,\n    pieceHashes,\n  };\n\n  return extendedInfo;\n};\n\nexport function infoCommand(file: string) {\n  const { announce, info, sha1, pieceHashes } = getInfo(file);\n  const infoStr = [\n    ['Tracker URL', announce],\n    ['Length', info.length],\n    ['Info Hash', sha1],\n    ['Piece Length', info['piece length']],\n    ['Piece Hashes', pieceHashes.join('\\n'), '\\n'],\n  ]\n    .map(([k, v, delim = ' ']) => `${k}:${delim}${v}`)\n    .join('\\n');\n  return infoStr;\n}\n","import { asByte } from '../decode';\nimport { hackStrToBytes } from '../hack';\n\nexport function encodeDict(dict: Record<string, unknown>) {\n  const keys = Object.keys(dict).sort();\n  const bytes: (number | number[])[] = [asByte('d')];\n  for (const key of keys) {\n    const keyStr = `${key.length}:${key}`;\n    bytes.push(Array.from(Buffer.from(keyStr, 'utf8')));\n    const val = dict[key];\n    if (typeof val === 'number') {\n      const intStr = `i${val}e`;\n      bytes.push(Array.from(Buffer.from(intStr, 'utf8')));\n    } else if (typeof val === 'string') {\n      const strBytes = hackStrToBytes.get(val);\n      if (!strBytes) {\n        throw new Error(`no bytes for ${val}`);\n      }\n      const prefix = `${strBytes.length}:`;\n      bytes.push(Array.from(Buffer.from(prefix, 'utf8')));\n      bytes.push(strBytes);\n    } else {\n      throw new Error(`unsupported val type for ${val}`);\n    }\n  }\n  bytes.push(asByte('e'));\n  return Buffer.from(bytes.flat());\n}\n","export { peers, peersCommand } from './peers';\nexport { PeerConnection } from './peer-connection';\n","import { decodeBencode } from '../decode';\nimport { hackStrToBytes } from '../hack';\nimport { getInfo } from '../info';\nimport { httpGetBuffer } from './http-get-buffer';\n\nconst peerId = 'a79a7e603a3d4357b52f';\nconst PORT = '6881';\n\nexport async function peersCommand(file: string) {\n  const peersResp = await peers(file);\n  return peersResp.peers.join('\\n');\n}\n\nexport async function peers(file: string) {\n  const info = getInfo(file);\n  const url = getPeersUrl(info);\n  const respStr = await httpGetBuffer(url);\n  const decoded = decodePeersResp(respStr);\n  return decoded;\n}\n\n// exported for testing\nexport function decodePeersResp(resp: Buffer) {\n  const { interval, peers } = JSON.parse(String(decodeBencode(resp)));\n  const peersBytes = hackStrToBytes.get(peers);\n  const peerStrs: string[] = [];\n  for (let i = 0; i < peersBytes.length; i += 6) {\n    const ip = peersBytes.slice(i, i + 4).join('.');\n    // const [p0, p1] = peersBytes.slice(i + 4, i + 6);\n    // const port = (p0 << 8) | p1;\n    const port = Buffer.from(peersBytes).readUInt16BE(i + 4);\n    const str = [ip, port].join(':');\n    peerStrs.push(str);\n  }\n  return { interval, peers: peerStrs };\n}\n\nfunction getPeersUrl(info): string {\n  const infoHashBuf = Buffer.from(info.sha1, 'hex');\n  if (infoHashBuf.length !== 20) {\n    throw new Error('infoHashRaw.length !== 20');\n  }\n\n  const params = new URLSearchParams();\n  params.append('peer_id', peerId);\n  params.append('port', PORT);\n  params.append('uploaded', '0');\n  params.append('downloaded', '0');\n  params.append('left', info.info.length.toString());\n  params.append('compact', '1');\n\n  let url = `${info.announce}?${params.toString()}`;\n  url += `&info_hash=${encodeInfoHash(info.sha1)}`;\n  return url;\n}\n\n// exported for testing\nexport function encodeInfoHash(hexStr: string): string {\n  const encoded: string[] = [];\n  // this is not `encodeURIComponent`\n  // the info hash is hex where each pair represents a byte\n  // we could escape them all with `%` but the challenge comments say that's not efficient enough\n  // so map the pairs that match a safe ascii\n  for (let i = 0; i < hexStr.length; i += 2) {\n    const pair = hexStr.slice(i, i + 2);\n    let e = '';\n    switch (pair.toLowerCase()) {\n      case '4c':\n        e = 'L';\n        break;\n      case '54':\n        e = 'T';\n        break;\n      case '68':\n        e = 'h';\n        break;\n      case '71':\n        e = 'q';\n        break;\n      default:\n        e = `%${pair}`;\n    }\n    encoded.push(e);\n  }\n  return encoded.join('');\n}\n","import http from 'node:http';\nimport url from 'node:url';\n\nexport function httpGetBuffer(requestUrl: string, maxRedirects = 7): Promise<Buffer> {\n  return new Promise((resolve, reject) => {\n    http\n      .get(requestUrl, (res) => {\n        const isRedirect = res.statusCode === 301 || res.statusCode === 302;\n        if (isRedirect && maxRedirects < 1) {\n          return reject(new Error('Too many redirects'));\n        } else if (isRedirect) {\n          const newLocation = res.headers.location;\n          const newUrl =\n            newLocation.startsWith('http://') || newLocation.startsWith('https://')\n              ? newLocation\n              : new url.URL(newLocation, requestUrl).href;\n          return httpGetBuffer(newUrl, maxRedirects - 1)\n            .then(resolve)\n            .catch(reject);\n        }\n\n        if (res.statusCode < 200 || res.statusCode >= 300) {\n          return reject(new Error('StatusCode=' + res.statusCode + ` url=${url}`));\n        }\n\n        const chunks = [];\n\n        res.on('data', (chunk) => {\n          chunks.push(chunk);\n        });\n\n        res.on('end', () => {\n          const buffer = Buffer.concat(chunks);\n          resolve(buffer);\n        });\n      })\n      .on('error', (err) => {\n        reject(err);\n      });\n  });\n}\n","import assert from 'node:assert';\nimport crypto from 'node:crypto';\nimport { Socket } from 'node:net';\n\nimport { Handshake, getHandshake, parseHandshake } from '../handshake/utils';\nimport { TorrentInfo } from '../info';\nimport { Message, MessageId } from './message';\nimport { seconds, minutes, getPieceLength, getBlocksForTorrentPiece } from './utils';\n\nenum State {\n  Unconnected = 'unconnected',\n  Connected = 'connected',\n  Handshaked = 'handshaked',\n  Downloading = 'downloading',\n  Error = 'error',\n  Closed = 'closed',\n}\n\nconst DEFAULT_WAIT = seconds(60);\n\nexport class PeerConnection {\n  private readonly received: Buffer[] = [];\n  private state: State = State.Unconnected;\n  private socket: Socket;\n  private bitfield: Message | null = null;\n\n  // spec says we start choked\n  private choke = true;\n\n  constructor(\n    private readonly torrent: TorrentInfo,\n    private readonly peer: string,\n  ) {}\n\n  async downloadSinglePiece(pieceNum: number): Promise<Buffer> {\n    assert(pieceNum >= 0, `pieceNum ${pieceNum} < 0`);\n    assert(\n      pieceNum < this.torrent.pieceHashes.length,\n      `index out of bounds: pieceNum ${pieceNum}, pieceHashes.length ${this.torrent.pieceHashes.length}`,\n    );\n\n    if (this.state !== State.Handshaked) {\n      await this.handshake();\n    }\n    this.state = State.Downloading;\n    console.error(\n      `Attempting download of piece ${pieceNum} of ${this.torrent.pieceHashes.length} from peer ${this.peer}`,\n    );\n\n    // instructions: wait for bitfield\n\n    // get to state where we can request piece\n    {\n      await this.sendMessage(MessageId.Interested);\n      let msg = await this.getNextMessage(minutes(5));\n      if (msg.isA(MessageId.Bitfield)) {\n        this.bitfield = msg;\n        // instructions: send interested\n        msg = await this.getNextMessage(minutes(5));\n      }\n      assert(msg.isA(MessageId.Unchoke), 'expected unchoke');\n      this.choke = false;\n    }\n\n    // const expectedPieceLen = getPieceLength(this.torrent, pieceNum);\n    const blocks: Buffer[] = [];\n\n    const blockLens = getBlocksForTorrentPiece(this.torrent, pieceNum);\n    // const baseBlockLen = blockLens[0];\n    let copied = 0;\n    for (let i = 0; i < blockLens.length; i++) {\n      const blockLen = blockLens[i];\n      await this.sendRequest(pieceNum, i, blockLen);\n      const pieceMsg = await this.getNextMessage(minutes(5));\n      assert(pieceMsg.isA(MessageId.Piece), `expected piece, got: ${pieceMsg}`);\n      console.error(`Piece message for p${pieceNum} b${i} ${pieceMsg}`, pieceMsg.payload);\n\n      // maybe this would need to be relaxed if we're pipelining\n      const rcvdPieceNum = pieceMsg.payload.readInt32BE(0);\n      assert(rcvdPieceNum === pieceNum, `rcvdPieceNum ${rcvdPieceNum} !== pieceNum ${pieceNum}`);\n\n      const rcvdOffset = pieceMsg.payload.readInt32BE(4);\n      assert(rcvdOffset === i, `offset ${rcvdOffset} does not match expected block number ${i}`);\n\n      const rcvdPayload = pieceMsg.payload.subarray(8);\n      assert(rcvdPayload.length === blockLen, `rcvdPayload.length ${rcvdPayload.length} !== blockLen ${blockLen}`);\n      blocks[rcvdOffset] = rcvdPayload;\n      copied += rcvdPayload.length;\n    }\n\n    const pieceBuff = Buffer.concat(blocks);\n    console.error(`Piece buffer p${pieceNum} size ${pieceBuff.length}b (copied: ${copied})`, pieceBuff);\n\n    // validate post conditions\n    {\n      assert(copied === pieceBuff.length, `copied ${copied} !== pieceBuff.length ${pieceBuff.length}`);\n\n      // sha1\n      const hasher = crypto.createHash('sha1');\n      hasher.update(pieceBuff);\n      const sha1 = hasher.digest('hex');\n      // assert(\n      //   sha1 === this.torrent.pieceHashes[pieceNum],\n      //   `sha1 ${sha1} !== expected ${this.torrent.pieceHashes[pieceNum]}`,\n      // );\n    }\n\n    return pieceBuff;\n  }\n\n  async handshake(maxWait = DEFAULT_WAIT): Promise<Handshake> {\n    assert(\n      this.state === State.Unconnected || this.state === State.Connected,\n      `handshake started in state: ${this.state}`,\n    );\n\n    if (this.state !== State.Connected) {\n      await this.connect();\n    }\n\n    assert(this.state === State.Connected, `handshake started in state: ${this.state}`);\n\n    const clientHandshake = getHandshake(this.torrent);\n    console.error(`Tx ${this.getDebugBufferStr(clientHandshake)}`, clientHandshake);\n    await new Promise<void>((resolve, reject) => {\n      this.socket.write(clientHandshake, (err) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve();\n        }\n      });\n    });\n\n    // assume return handshake fits in one data\n    const serverHandshake = await this.getNextBuffer(maxWait);\n    const parsed = parseHandshake(serverHandshake);\n    return parsed;\n  }\n\n  private connect(maxWait = DEFAULT_WAIT): Promise<void> {\n    assert(this.state === State.Unconnected, `connect started in state: ${this.state}`);\n    const [host, portStr] = this.peer.split(':');\n    const port = Number.parseInt(portStr, 10);\n    if (!(Number.isSafeInteger(port) && port > 0)) {\n      throw new Error(`bad port: ${portStr}`);\n    }\n\n    const conn = this;\n\n    return new Promise<void>((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        reject(new Error(`Connection to ${this.peer} timed out after ${maxWait}ms}`));\n        conn.state = State.Error;\n      }, maxWait);\n      conn.socket = new Socket()\n        .on('data', this.handleData)\n        .on('close', this.handleClose)\n        .on('error', this.handleError)\n        .connect(port, host, () => {\n          console.error(`Connected to peer ${this.peer}`);\n          conn.state = State.Connected;\n          clearTimeout(timeout);\n          resolve();\n        });\n    });\n  }\n\n  close = async () => {\n    console.error(`Closing connection to ${this.peer}`);\n    this.received.length = 0;\n    if (![State.Error, State.Closed].includes(this.state)) {\n      this.state = State.Closed;\n    }\n    this.socket.destroy();\n  };\n\n  // TODO: loop - each piece has multiple blocks, the last may not be a full size block\n  private async sendRequest(piece = 0, block = 0, blockLen = 16 * 1024): Promise<void> {\n    if (this.choke) {\n      throw new Error('sent request while choked');\n    }\n    console.error(`Sending request for piece ${piece}, block ${block}, length ${blockLen}`);\n    const req = Buffer.alloc(12);\n    req.writeUInt32BE(piece, 0);\n    req.writeUInt32BE(block, 4);\n    req.writeUInt32BE(blockLen, 8);\n    return this.sendMessage(MessageId.Request, req);\n  }\n\n  private async sendMessage(id: MessageId, payload?: Buffer): Promise<void> {\n    const buffer = Message.makeSendBuffer(id, payload);\n    return new Promise((resolve, reject) => {\n      this.socket.write(buffer, (err) => {\n        const debugStr = this.getDebugBufferStr(buffer);\n        if (err) {\n          console.error(`Error Tx ${debugStr}`, buffer);\n          reject(err);\n        } else {\n          console.error(`Tx ${debugStr}`, buffer);\n          resolve();\n        }\n      });\n    });\n  }\n\n  private getDebugBufferStr = (buffer: Buffer): string => {\n    const debugStr = `${buffer.length}b\\t${Message.getDebugType(buffer)}\\t`;\n    return debugStr;\n  };\n\n  private handleData = (data: Buffer) => {\n    console.error(`Rx ${this.getDebugBufferStr(data)}`, data);\n    this.received.push(data);\n  };\n\n  private handleError = (err: Error) => {\n    console.error('Error', err);\n    this.state = State.Error;\n  };\n\n  private handleClose = () => {\n    console.error('Closed');\n    if (this.state !== State.Error) {\n      this.state = State.Closed;\n    }\n  };\n\n  private getNextMessage = async (maxWait = DEFAULT_WAIT * 10): Promise<Message> => {\n    const firstBuff = await this.getNextBuffer(maxWait);\n    const statedMessageLen = firstBuff.readInt32BE(0);\n    const statedMessageId = firstBuff.readInt8(4);\n    assert(\n      statedMessageLen >= firstBuff.length - 5,\n      `statedPayloadLen: ${statedMessageLen}, buff.length: ${firstBuff.length}`,\n    );\n    if (firstBuff.length - 4 === statedMessageLen) {\n      const msg = new Message(firstBuff);\n      return msg;\n    }\n    console.error(\n      `Got partial payload for message type ${statedMessageId}, received: ${\n        firstBuff.length - 4\n      } of ${statedMessageLen}`,\n    );\n    const totalBuff = Buffer.alloc(statedMessageLen + 4);\n    firstBuff.copy(totalBuff, 0);\n\n    let iterationLimit = 10;\n    let copied = firstBuff.length;\n    do {\n      const left = totalBuff.length - copied;\n      console.error(\n        `Copied ${((copied / totalBuff.length) * 100).toFixed(0)}%  ${copied} of ${\n          totalBuff.length\n        }, remaining: ${left} `,\n      );\n      assert(iterationLimit-- > 0, `too many iterations`);\n      const next = await this.getNextBuffer(maxWait);\n      if (Message.isKeepAlive(next)) {\n        console.error(`Got keep-alive while waiting for more data in same block, continuing`);\n        continue;\n      }\n      next.copy(totalBuff, copied);\n      copied += next.length;\n    } while (copied < totalBuff.length);\n    assert(copied === totalBuff.length, `copied ${copied} !== totalBuff.length ${totalBuff.length}}`);\n    return new Message(totalBuff);\n  };\n\n  private getNextBuffer = async (maxWait = DEFAULT_WAIT): Promise<Buffer> => {\n    // hack - seems like there should be a way to wrap the socket handler in an async generator\n    return new Promise((resolve, reject) => {\n      const current = this.received.shift();\n      if (current) {\n        // console.error(`No wait`);\n        resolve(current);\n        return;\n      }\n\n      const cancelLimit = setTimeout(() => {\n        reject(new Error(`Timeout, waited longer than ${maxWait}ms`));\n      }, maxWait);\n\n      const cancelCheck = setInterval(() => {\n        // process.stderr.write(`.`);\n        if (\n          [State.Error, State.Closed].includes(this.state) &&\n          // the connection could be closed before the interval allows the consumer to pop the buffered message(s)\n          !this.received.length\n        ) {\n          // process.stderr.write(`\\n`);\n          clearInterval(cancelCheck);\n          clearTimeout(cancelLimit);\n          reject(\n            new Error(\n              `getNextBuffer() -> cancelCheck -> state: ${this.state}, received.length: ${this.received.length}`,\n            ),\n          );\n          return;\n        }\n        const current = this.received.shift();\n        if (current) {\n          // process.stderr.write(`\\n`);\n          resolve(current);\n          clearInterval(cancelCheck);\n          clearTimeout(cancelLimit);\n        }\n      }, 100);\n    });\n  };\n}\n","import assert from 'node:assert';\n\nimport { TorrentInfo } from '../info';\n\nexport type Handshake = {\n  peerId: Buffer;\n  peerIdHex: string;\n  handshakeResp: Buffer;\n};\n\nexport function parseHandshake(data: Buffer): Handshake {\n  // should validate the info hash\n  const peerId = data.subarray(data.length - 20);\n  return {\n    peerId,\n    peerIdHex: peerId.toString('hex'),\n    handshakeResp: data,\n  };\n}\n\nexport function getHandshake(info: TorrentInfo): Buffer {\n  const prefix = getHandshakePrefix();\n\n  // seems like this should be part of the prefix\n  // but the return handshake has a non-zero for one of these\n  const reserved = Buffer.from([0, 0, 0, 0, 0, 0, 0, 0]);\n  assert(reserved.length === 8, 'reserved.length !== 8');\n\n  const infoHash = Buffer.from(info.sha1, 'hex');\n  assert(infoHash.length === 20, 'infoHash.length !== 20');\n\n  const peerId = Buffer.from('00112233445566778899');\n  assert(peerId.length === 20, 'peerId.length !== 20');\n\n  const handshake = Buffer.concat([prefix, reserved, infoHash, peerId]);\n\n  return handshake;\n}\n\nfunction getHandshakePrefix(): Buffer {\n  const length = Buffer.from([19]);\n  assert(length.length === 1, 'length.length !== 1');\n\n  const protocol = Buffer.from('BitTorrent protocol');\n  assert(protocol.length === 19, 'protocol.length !== 19');\n\n  const prefix = Buffer.concat([length, protocol]);\n\n  return prefix;\n}\n\nexport function isHandshake(data: Buffer): boolean {\n  if (data.length < 68) {\n    return false;\n  }\n  const prefix = getHandshakePrefix();\n  for (let i = 0; i < prefix.length; i++) {\n    if (data[i] !== prefix[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n","import assert from 'node:assert';\n\nimport { isHandshake } from '../handshake/utils';\n\nexport enum MessageId {\n  Choke = 0,\n  Unchoke = 1,\n  Interested = 2,\n  NotInterested = 3,\n  Have = 4,\n  Bitfield = 5,\n  Request = 6,\n  Piece = 7,\n  Cancel = 8,\n}\n\nexport class Message {\n  readonly raw: Buffer;\n  readonly msgLen: number;\n  readonly id: number;\n  readonly payload: Buffer;\n\n  constructor(buffer: Buffer) {\n    this.raw = buffer;\n    this.msgLen = Message.getMessageLength(buffer);\n    this.id = Message.getMessageId(buffer);\n    this.payload = Message.getMessagePayload(buffer);\n    assert(MessageId[this.id], `bad id: ${this.id}`);\n    assert(\n      this.msgLen === this.payload.length + 1,\n      `length ${this.msgLen} !== payload.length ${this.payload.length} + 1`,\n    );\n  }\n\n  isA(id: MessageId): boolean {\n    return this.id === id;\n  }\n\n  toString() {\n    return `Message(id: ${MessageId[this.id]}, payload: ${this.msgLen - 1}b)`;\n  }\n\n  static isKeepAlive(data: Buffer): boolean {\n    return data.length === 4 && Message.getMessageLength(data) === 0;\n  }\n\n  static getDebugType(data: Buffer): string {\n    if (Message.isKeepAlive(data)) {\n      return 'keep-alive';\n    }\n    const id = Message.getMessageId(data);\n    if (MessageId[id]) {\n      return MessageId[id];\n    }\n    if (isHandshake(data)) {\n      return 'handshake';\n    }\n    return '';\n  }\n\n  static getMessageId(data: Buffer): number {\n    return data.readInt8(4);\n  }\n\n  static getMessageLength(data: Buffer): number {\n    return data.readInt32BE(0);\n  }\n\n  static getMessagePayload(data: Buffer): Buffer {\n    return data.subarray(5);\n  }\n\n  static makeSendBuffer(id: MessageId, payload?: Buffer): Buffer {\n    assert(MessageId[id], `bad id: ${id}`);\n    const payloadLen = payload?.length ?? 0;\n    const buffer = Buffer.alloc(5 + payloadLen);\n    buffer.writeUInt32BE(1 + payloadLen, 0);\n    buffer.writeUInt8(id, 4);\n    if (payloadLen) {\n      payload.copy(buffer, 5);\n    }\n    return buffer;\n  }\n}\n","import assert from 'assert';\n\nimport { TorrentInfo } from '../info';\n\nexport function getBlocksForTorrentPiece(torrent: TorrentInfo, pieceNum: number): number[] {\n  const pieceLen = getPieceLength(torrent, pieceNum);\n\n  const blocks = getBlocks(pieceLen);\n  let total = 0;\n  for (const b of blocks) {\n    total += b;\n  }\n  assert(\n    total === pieceLen,\n    `total ${total} !== pieceLen ${torrent.info.length}, pieceNum: ${pieceNum}, info['piece length']: ${torrent.info['piece length']}]`,\n  );\n  return blocks;\n}\n\nexport function getPieceLength(torrent: TorrentInfo, pieceNum: number): number {\n  assert(\n    pieceNum < torrent.pieceHashes.length,\n    `index out of bounds: pieceNum ${pieceNum}, torrent.pieceHashes.length ${torrent.pieceHashes.length}`,\n  );\n  const isLast = pieceNum === torrent.pieceHashes.length - 1;\n  const pieceLen = isLast ? torrent.info.length % torrent.info['piece length'] : torrent.info['piece length'];\n  return pieceLen;\n}\n\nfunction getBlocks(remainingSize: number, blockSize = 16 * 1024, accum?: number[]): number[] {\n  const nextBlock = remainingSize > blockSize ? blockSize : remainingSize;\n  assert(nextBlock <= remainingSize, `nextBlock ${nextBlock} > remainingSize ${remainingSize}`);\n  return nextBlock === remainingSize\n    ? [...(accum ?? []), nextBlock]\n    : getBlocks(remainingSize - nextBlock, blockSize, [...(accum ?? []), nextBlock]);\n}\n\nexport function minutes(m: number) {\n  return seconds(m * 60);\n}\n\nexport function seconds(s: number) {\n  return s * 1_000;\n}\n","export function sample<T>(arr: T[]): T {\n  const index = Math.floor(Math.random() * arr.length);\n  return arr[index];\n}\n","export * from './handshake';\n","import { getInfo } from '../info';\nimport { PeerConnection } from '../peers';\n\nexport async function handshakeCommand(file: string, peer: string): Promise<string> {\n  const conn = new PeerConnection(getInfo(file), peer);\n  const { peerIdHex } = await conn.handshake();\n  await conn.close();\n  return `Peer ID: ${peerIdHex}`;\n}\n"],"names":[],"version":3,"file":"main.js.map","sourceRoot":"../"}